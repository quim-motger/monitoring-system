% Chapter Template

\chapter{Sistema d'adaptabilitat} % Main chapter title

\label{DissenySistema} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

Els models UML prèviament descrits ens permeten dissenyar i modelar de forma estandarditzada el sistema de monitoratge. Proporciona, semànticament, tots els recursos necessaris per traduir propostes de configuracions de sistemes en accions reals sobre els monitors implementats.\\

El següent pas és el disseny i implementació d'un sistema que, a partir dels models anteriors, i de tot el domini que defineixen, sigui capaç de gestionar la persistència dels models, obtenir-ne els necessaris per aplicar reconfiguracions, actualitzar els models d'acord a aquestes modificacions, i traduir la informació implícita als models en accions de reconfiguració reals a enviar al sistema de monitoratge.\\

Procedirem a presentar els diferents components que componen aquest sistema.

\section{Model Repository}

El primer component que cal introduir per començar a entendre el \textit{workflow} del sistema d'adaptabilitat és el \textbf{Model Repository}. Aquest component actua en termes genèrics com a un repositori que gestiona la persistència del conjunt de models UML que intervenen en el modelatge del sistema i la seva reconfiguració. Això, per tant, implica tot el conjunt de models descrits anteriorment: \textit{Base Model}, \textit{Feature Model}, \textit{Feature Configuration}, \textit{Pattern Model}, \textit{Profile Model} i \textit{Adaptability Model}.\\

Principalment, les funcionalitats que ha de satisfer són les següents:

\begin{enumerate}
\item Gestionar la persistència dels models en disc
\item Mapejar i encapsular l'estructura de directoris definida per estructurar els models segons el seu tipus
\item Encapsular els mètodes CRUD bàsics per la gestió dels models, aïllant la lògica interna de la resta de components
\item Encapsular mètodes extensius que permetin obtenir models sota unes certes característiques
\end{enumerate}

D'aquesta manera, podem concebre aquest component com una abstracció entre la naturalesa interna dels models i la lògica associada a la càrrega/descàrrega de fitxers amb el nostre sistema, assignant la responsabilitat d'aquests primers punts al Model Repository.\\

Una primera aproximació que ens podríem plantejar seria implementar un component unitari que definís un controlador (que després s'exposaria com a servei per integrar a IF) amb tots els mètodes necessaris per la gestió dels models. Si al nostre sistema únicament resultés d'interès les operacions bàsiques de models, aquesta seria una bona alternativa, ja que estaríem simplificant l'arquitectura del sistema, i hi hauria poc marge per la millora. Però si anem un pas més enllà, i plantegem les necessitats de reconfiguració i adaptabilitat del nostre sistema, veiem que un controlador basat en operacions CRUD únicament ens permetria definir reconfiguracions on tots els models que intervenen en l'adaptació són triats estàticament, no dinàmicament. És a dir: el potencial que oferiria el Model Repository seria referenciar els models implicats en una adaptació mitjançant els seus identificadors, que haurien de ser introduïts manualment.\\

Això per tant implica que no podríem aplicar escenaris d'adaptació com per exemple:\\

\centerline{\textit{Actualitzar el sistema de monitoratge amb la darrera Feature Configuration computada}}\bigskip

Si tornem al cicle \textit{MAPE-k}, suposant un sistema de \textit{\textbf{P}lanificació} que produeix noves propostes de configuració (FC), aquest enviaria periòdicament aquests models al nostre sistema d'adaptabilitat. Si el nostre sistema és capaç de consultar les dates en què aquestes propostes es van afegint, és capaç de computar quina és la darrera afegida. I en definitiva, és capaç de computar, de forma automàtica i sense necessitat de donar-li cap mena d'informació, quins canvis aplicar al sistema de monitoratge.\\

Aquest escenari és clau pel nostre projecte. L'automatització del nostre sistema ve donada precisament gràcies a la persistència dels models UML i a l'actualització d'aquests, responsabilitat d'un altre sistema, a partir dels quals aquest és capaç de llegir, processar i traduir en modificacions reals sobre les activitats de monitoratge. Aquest escenari, però, és només un exemple de possible escenari d'adaptabilitat, basat en un criteri com la data, que serà el que nosaltres farem servir pel desenvolupament del projecte. Però el potencial està en veure que els criteris poden ser diversos, sempre i quan es treballin amb metadades que podem extreure a partir dels models, com és el cas de la data de generació de les propostes de reconfiguració.\\

Addicionalment a aquest problema, alguns models tenen dependències amb altres models UML. El cas més evident, l'\textit{Adaptability Model}, té dependències amb \textit{Feature Configurations}, que alhora tenen dependències amb \textit{Feature Models}, i també amb \textit{Pattern Models} i \textit{Profile Models}. La resolució i gestió d'aquestes dependències pot arribar a ser extremadament complicada si, al carregar un d'aquests models, necessitem computar i resoldre quines són aquestes dependències cada vegada que volem carregar el Model Repository a memòria per executar una adaptació des del component encarregat d'aquest aspecte, l'Adapter, que satisfent el criteri de distribució del nostre sistema pot no tenir accés al mateix repositori en disc que el Model Repository. \\

Partint d'aquestes necessitats, és evident que necessitem estendre els mètodes de lectura de models a mètodes més complerts, on utilitzem dades auxiliars per fer cerques dins el nostre repositori. És en aquest punt quan aquesta primera aproximació resulta ineficient: si volem accedir a les metadades dels fitxers dels models, tals com la data de creació, l'autor, el sistema que l'ha computat, etc. (més endavant les veurem amb més detall), carregar tots els fitxers dinàmicament per accedir a aquestes dades per fer la cerca resulta molt ineficient. És per això que, alternativament, utilitzarem la següent arquitectura per gestionar la persistència de models:

\begin{itemize}
\item \textbf{Model Repository Manager.} Component que gestiona les metadades dels models, emmagatzemades en una base de dades relacionals, i que estén un controlador amb els mètodes de cerca per obtenir les metadades dels models desitjats.
\item \textbf{Model Repository Client.} Component que es comunica amb el Model Repository Manager per obtenir les dades dels models, gestiona la persistència del repositori de models, i encapsula els mètodes i objectes per obtenir i treballar amb els models associats a les reconfiguracions.
\end{itemize}

D'aquesta manera, el primer assumeix les responsabilitats de cerca i gestió de models en base a les seves metadades, i el segon assumeix la responsabilitat principal d'encapsular programàticament l'accés als models, per tal que la resta de components del sistema d'adaptabilitat puguin aïllar-se de la lògica interna d'aquest punt.

\subsection{Model Repository Manager}

Satisfent les necessitats del Model Repository Manager, necessitem contemplar els següents punts:

\begin{enumerate}
\item Disseny i implementació d'una base de dades relacional que emmagatzemi les metadades per cada tipus de model.
\item Disseny i implementació d'un component que accedeixi a la base de dades, i que exposi a través d'un controlador els mètodes de consulta i modificació dels models.
\end{enumerate}

\subsubsection{Disseny de la base de dades}

En primer lloc necessitem definir quines seran les metadades que considerarem per cada model. Generalment, podem considerar que tots els models definits tindran les següents dades:

\begin{itemize}
\item \textbf{Id.} Identificador d'aquell model, únic pel tipus de model (\textit{Base Model}, \textit{Feature Model}...) que representa.
\item \textbf{Name.} Nom del fitxer del model (sense l'extensió).
\item \textbf{AuthorId.} Identificador de l'autor del model.
\item \textbf{CreationDate.} Data de creació del model.
\item \textbf{LastModificationDate.} Data de la darrera modificació del fitxer del model.
\item \textbf{FileExtension.} Extensió del fitxer (.uml, .vql, .yamfc ...)
\item \textbf{SystemId.} Utilitzat dins el context SUPERSEDE per identificar els models que corresponen als diferents escenaris. En el nostre cas, aquest sempre serà \textit{MonitoringReconfiguration}.
\item \textbf{RelativePath.} Ruta relativa del directori \textit{root} on s'emmagatzema el model.
\item \textbf{Dependencies.} Llistat d'identificadors dels models dels quals depèn aquest model.
\end{itemize}

Tot i així, addicionalment existeix la possibilitat d'estendre atributs específics pels diferents models. Considerarem útils pel nostre context els següents:

\begin{itemize}
\item \textbf{Base Model}
\begin{itemize}
\item \textbf{Status.} Indica si el model ha estat computat per un sistema extern (\textit{Computed}), si és el resultat d'una adaptació dins el sistema d'adaptabilitat (\textit{Enacted}), o bé si ha estat dissenyat manualment (\textit{Designed}).
\end{itemize}
\item \textbf{Feature Configuration}
\begin{itemize}
\item \textbf{Status.} Indica si la \textit{Feature Configuration} ha estat computada per un sistema extern (\textit{Computed}), si s'ha aplicat com a adaptació dins el sistema (\textit{Enacted}), o bé si ha estat dissenyada manualment (\textit{Designed}).
\end{itemize}
\item \textbf{Adaptability Model}
\begin{itemize}
\item \textbf{Feature Id.} Identificador de la \textit{feature} referenciada per l'Adaptability Model.
\end{itemize}
\end{itemize}

A partir d'aquestes dades podem procedir al disseny de la base de dades del repositori de metadades. Al existir atributs comuns i atributs diferenciats, hem de decidir quin tipus d'herència apliquem a la base de dades. Recordant les tres opcions, aplicades al nostre cas obtindríem el següent:

\begin{itemize}
\item \textbf{\textit{Single table inheritance.}} Definir una única taula a la base de dades \textit{Model} que inclogui tots els atributs possibles, inclosos els específics, i prengui valors nulls per aquells que no tenen aquell atribut.
\item \textbf{\textit{Class table inheritance.}} Definir una taula genèrica \textit{Model} i N taules addicionals per cada tipus que referenciïn la primera, amb els atributs addicionals per cada cas.
\item \textbf{\textit{Concrete table inheritance.}} Definir una taula per cada tipus de model i replicar els atributs comuns.
\end{itemize}

En el nostre cas, optarem per l'opció \textit{concrete table inheritance}. La raó principal d'aquesta opció és que, tot i compartir la major part de les dades, les entitats de models amb tipus diferents mai tindrà sentit contemplar-les conjuntament. És a dir: qualsevol lectura o modificació de models es farà sobre un model (o conjunt de models) d'un tipus específic, mai sobre models de forma genèrica (no tindrà sentit concebir l'entitat \textit{Model} abstracta). Si considerem la segona opció, veiem que seria molt ineficient, ja que caldria fer \textit{joins} internes per obtenir les dades els models, i per la mateixa raó que la ja esmentada sabem que seria un cost innecessari. Per tant, optarem per definir una taula per cada tipus, mantenint així la independència de les metadades entre models. A l'apèndix ~\ref{AppendixA} podem veure el disseny proposat de la base de dades, d'acord als 6 tipus de models definits.\\

D'aquesta manera, la identificació d'un model queda definida per \textbf{id + ModelType}, el primer com a atribut explícit de metadades i el segon com a metadada implícita derivada de la taula en la qual emmagatzemem el model.

\subsubsection{Disseny i implementació del domini i controlador}

Modelat l'esquema de les metadades a la base de dades, podem procedir a implementar les classes de domini amb les quals treballarem per operar sobre aquestes. Partint del disseny anterior necessitem definir dos aspectes. En primer lloc, necessitem \textbf{modelar la jerarquia} de models, segons els atributs genèrics i els atributs específics de cada model. En segon lloc, definir com modelarem i identificarem el llistat de dependències de cada model.\\

\begin{figure}
\centering
\includegraphics[width=11cm]{Figures/Figure21}
\decoRule
\caption{Disseny del domini del Model Repository Manager}
\label{fig:Figura21}
\end{figure}

A la figura ~\ref{fig:Figura21} es presenta el diagrama simplificat de la proposta de disseny. Per la definició dels models, definim una classe genèrica \textit{GenericModel} amb tots els atributs genèrics a tots els models. Addicionalment, s'implementa una classe per cada tipus de model específic (al diagrama apareixen \textit{BaseModel} i \textit{ProfileModel}, a mode d'exemple). Als atributs que apareixen al diagrama cal afegir els mètodes \textit{getters} i \textit{setters} tradicionals, no afegits per simplificació de l'esquema, així com els constructors. Per sobre de \textit{GenericModel} definim una classe abstracta \textit{IModel}, requisit establert per SUPERSEDE per futures extensions. \\

Paral·lelament es presenta una proposta de gestió de les dependències. Ja que els nostres models es troben identificats per la parella \textit{id + ModelType}, es proposa la definició d'una interfície \textit{IModelId} genèrica, totalment genèrica i sense cap mètode, oberta a possibles extensions i refactoritzacions necessàries pel context de SUPERSEDE. Per gestionar aquestes dependències pel nostre context, definim una nova interfície, \textit{ITypedModelId}, que defineix els mètodes per extreure les dues dades necessàries per identificar un model, \textit{getNumber} i \textit{getModelType}. D'aquesta interfície definim una implementació, que obté aquests dos valors definits als mètodes anteriors mapejant directament aquests atributs. D'aquesta manera, el llistat de dependències dels models usats en la reconfiguració de monitors seran instàncies de la classe \textit{TypedModelId} amb els dos atributs \textit{id} i \textit{ModelType}.\\ 

Amb aquest domini podem procedir a implementar el controlador i, posteriorment, la seva exposició com a servei REST per la integració amb IF. Sense entrar en gaires detalls tècnics sobre aquesta part (molt similar a les anteriors exposicions com serveis), definirem les 5 operacions CRUD bàsiques, sempre considerant per \textit{ModelType}. També serà responsabilitat del Model Repository Manager, associada a cadascuna d'aquestes operacions, la gestió del contingut dels models. Aquesta responsabilitat consistirà bàsicament en emmagatzemar en disc, segons on es trobi desplegat aquest component, els fitxers dels models, amb el contingut determinat. Aquesta persistència es gestionarà definint el contingut del model com un string, tant per indicar al Model Repository Manager el contingut a emmagatzemar, com per obtenir-lo quan es consultin les dades d'un mateix.

\begin{enumerate}
\item \textbf{Llista models d'un tipus.} Retorna les metadades de tots els models existents d'un tipus determinat.
\item \textbf{Obté un model.} Retorna les metadades i un string amb el contingut d'un model donat un identificador i un \textit{ModelType}.
\item \textbf{Crea un nou model.} Emmagatzema un nou model amb les metadades passades al Model Repository Manager i guarda un fitxer a disc amb el contingut, el nom i l'extensió determinats a les metadades.
\item \textbf{Actualitza les metadades d'un model.} Donat un identificador i un \textit{Model Type}, actualitza els valors de les metadades d'un model i el contingut, nom i/o extensió del fitxer (quan s'escaigui). 
\item \textbf{Eliminar les metadades d'un model.} Donat un identificador i un \textit{Model Type}, elimina la instància de metadades d'aquest model i elimina el fitxer del repositori.
\end{enumerate}

A l'apèndix ~\ref{AppendixA} es troba definida l'API utilitzada per la integració d'aquest component.

\subsection{Model Repository Client}

Aquest subcomponent del Model Repository s'encarrega d'actuar de pont entre el Model Repository Manager, que gestiona les dades/metadades dels models, i l'Adapter, component que utilitzarà el Model Repository per obtenir les instàncies dels models que necessita per gestionar les adaptacions de reconfiguracions. El disseny i la implementació d'aquest component han estat principalment realitzats per partners tercers del projecte, amb algunes col·laboracions i aportacions específiques per l'adaptabilitat dels models, especialment per la seva orientació a validar el cas d'ús de reconfiguració de monitors. Per tant, procedirem a explicar únicament aquells aspectes realitzats com a part del treball d'aquest TFG i els conceptes necessaris per entendre el seu funcionament.\\

Des d'un punt de vista de \textbf{disseny}, aquest component defineix una interfície \textit{IModelRepository} que defineix, per una banda, els mètodes CRUD per cadascun dels 6 tipus de models existents al sistema:
 
\begin{itemize}
\item 
\end{itemize}
 
Addicionalment, defineix mètodes de cerca més complexos en base a les metadades dels models. Aquests mètodes seran els que ens permetran executar les adaptacions de forma automatitzada, sense necessitat de definir models específics, a mode de l'exemple introduït anteriorment sobre la cerca de la darrera configuració computada. D'aquests mètodes, ens interessaran especialment els següents:

\begin{itemize}
\item \textbf{Obté el \textit{Base Model} més actual} - Permet obtenir el darrer \textit{Base Model} del sistema, que representa per tant l'estat actual del sistema de monitoratge, i ens servirà per agafar com a model per aplicar els canvis de reconfiguració
\item \textbf{Obté la darrera \textit{Feature Configuration} computada} - Obté la darrera \textit{Feature Configuration} amb l'atribut \textit{status} amb valor \textit{Computed}. D'aquesta manera, podem obtenir aquella darrera proposta de configuració que no s'ha executat encara (i per tant, que no té l'atribut \textit{status} amb valor \textit{Enacted})
\item \textbf{Obté la darrera \textit{Feature Configuration} executada} - Obté la darrera \textit{Feature Configuration} amb l'atribut \textit{status} amb valor \textit{Enacted}. D'aquesta manera, podem obtenir la darrera configuració executada, i juntament amb l'anterior mètode, podem computar les diferències entre les dues.
\item \textbf{Obté els \textit{Adaptability Models} candidats} - Obté el llistat de \textit{Adaptability Models} donat un \textit{systemId}. En el nostre cas, ens interessar obtenir aquells amb sistema \textit{MonitoringReconfiguration}, que representaran totes les adaptacions possibles a aplicar dins el nostre context.
\end{itemize}

La implementació d'aquesta interfície defineix la interacció amb el Model Repository Manager i la gestió de persistència dels models per tal de poder referenciar i treballar amb ells des del component Adapter. A l'apèndix ~\ref{AppendixA} es pot consultar la interfície definida amb tots els mètodes que formen part del Model Repository Client, i que seran els utilitzats per executar la reconfiguració d'un monitor. 

\section{Model Adapter}


\section{Adapter}

Satisfets els requisits tècnics i funcionals del Model Repository disposem d'un component que ens permet carregar dinàmicament tots els models i utilitzar els mètodes que la llibreria UML2 defineix amb els mateixos. Paral·lelament, el Model Adapter ens satisfà la necessitat d'adaptació dinàmica de diagrames de classe UML. El següent pas és definir el component que assumirà la responsabilitat de \textbf{gestionar i computar les reconfiguracions}. Aquesta responsabilitat serà assumida per l'Adapter, la responsabilitat principal del qual serà la interacció amb el Model Repository i el Model Adapter per aplicar l'algorisme que a continuació definim per computar reconfiguracions.\\

\subsection{Algorisme d'adaptabilitat}

L'\textbf{algorisme d'adaptabilitat} de models, o bé reconfiguració de monitors pel nostre cas d'estudi, consisteix en la implementació d'un algorisme que resolgui la següent problemàtica:

\begin{center}
\textit{Davant una petició de reconfiguració del sistema, calculem totes les diferències entre la \textbf{darrera Feature Configuration aplicada} i la \textbf{darrera Feature Configuration computada} i trobem totes les diferències de seleccions. Per cada diferència (és a dir, per cada \textbf{selection} present a una de les dues \textbf{Feature Configurations} però no a l'altra), apliquem les \textbf{accions definides als Adaptability Models} corresponents al \textbf{Base Model}, segons si aquesta s'activa a la nova configuració (apareix a la nova FC) o bé es desactiva (no apareix).}
\end{center}

Per entendre millor aquest plantejament, anem a analitzar pas per pas quins són els passos que s'han de realitzar per passar d'identificar una \textit{feature} a modificar el \textit{Base Model}:

\begin{enumerate}
\item Obtenim la \textbf{darrera \textit{Feature Configuration}} amb \textit{status = Computed}, que representa la última configuració del sistema proposada
\item Obtenim la \textbf{darrera \textit{Feature Configuration}} amb \textit{status = Enacted}, que representa la última configuració del sistema aplicada
\item Obtenim el \textbf{darrer \textit{Base Model} del sistema}, que representa l'estat actual del sistema de monitoratge
\item Computem totes les diferències a nivell de \textbf{selections}, que apareixen només a una de les dues \textit{Feature Configurations}.
\item Per cada \textit{selection} diferent trobada:
\begin{enumerate}
\item Obtenim els \textbf{\textit{Adaptability Models} associats a la \textit{feature}} que representa aquella \textit{selection}
\item Per cada \textit{Adaptability Model} obtingut:
\begin{enumerate}
\item Obté tots els \textbf{\textit{pointcuts} definits per l'\textit{Adaptability Model}}
\item Per cada \textit{pointcut} obtingut:
\begin{enumerate}
\item Obté el \textbf{\textit{pattern} definit per aquell \textit{pointcut}}
\item Utilitza el component \textit{Model Query} per trobar tots els \textbf{elements al \textit{Base Model}} segons el \textbf{\textit{pattern} obtingut}
\item Etiqueta amb el \textit{role} definit pel \textit{pointcut} tots els elements trobats pel \textit{Model Query}
\end{enumerate}
\item Obté les \textbf{\textit{compositions} definides per l'\textit{Adaptability Model}}
\item Per cada \textit{composition}:
\begin{enumerate}
\item Comprova si aquella \textit{composition} defineix l'\textbf{activació o desactivació} de la \textit{feature}. 
\item En cas que coincideixi amb el valor de l'activació/desactivació de la \textit{feature}, es comunica amb el Model Adapter per aplicar l'adaptació corresponent i obté el \textit{Base Model} adaptat.
\end{enumerate}
\end{enumerate}
\end{enumerate}
\item Actualitza el Model Repository amb el \textbf{nou \textit{Base Model}} i la nova \textit{Feature Configuration}.
\end{enumerate}

\subsection{Disseny i diagrama de seqüència}

\begin{figure}[!h]
\centering
\includegraphics[width=13cm]{Figures/Figure22}
\decoRule
\caption{Diagrama de seqüència de la reconfiguració del sistema amb l'Adapter}
\label{fig:Figura22}
\end{figure}

\section{Enactor}
